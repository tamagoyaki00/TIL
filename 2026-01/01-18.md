## カプセル化

アクセス修飾子：　クラス・メンバ変数・メソッドの公開範囲を指定できる

| アクセス修飾子 | 同クラス | 同パッケージ | サブクラス | 他クラス |
| --- | --- | --- | --- | --- |
| public | 〇 | 〇 | 〇 | 〇 |
| protected | 〇 | 〇 | 〇（※） | × |
| default（なし） | 〇 | 〇 | × | × |
| private | 〇 | × | × | × |

※ protected は別パッケージのサブクラスからもアクセス可能（継承経由のみ）

メンバ変数は隠蔽(private)、クラス・メソッドは公開(public)する設計方針をカプセル化という

メリット

- 代入前処理（不正な値を防ぐことができる）
- プログラムの修正範囲が狭くなる

例：

```ruby
public class Student2 {
	private String name;
	private int score;
	
	public Student2(String n) {
		name = n;
	}
	public void setScore(int s) {
		if(0 <= s && s <= 100) {
			score = s;
		} else {
			System.out.println(name + "さんの点数が範囲外です");
			score = 0;
		}
	}
	void display() {
		System.out.println(name + "さん：" + score + "点");
	}

}
```

```ruby
public class StuSample2 {

	public static void main(String[] args) {
		Student2 stu1 = new Student2("菅原");
		stu1.setScore(80);
		stu1.display();
		
		Student2 stu2 = new Student2("村山");
		stu2.setScore(-50);
		// stu2.score = -50;
		stu2.display();
	}

}
```

private指定をしているので、`stu.score = -50;` とするとアクセスができませんよというエラーがでます

<aside>
💡

エラー文

Exception in thread "main" java.lang.Error: Unresolved compilation problem:
フィールド Student2.score は不可視です

</aside>

これで万一、不正な値が入力されようとしても必ずsetScoreをメソッドを通すので精査できるようになる。

また仮にscoreをmathscoreに変更したとしても、同じクラス内のsocreのみ修正すればいい。

## 第四章　継承

継承とは、既存のクラスをもとに変数やメソッドを追加したクラスを作ること。親クラスをスーパークラス、子クラスをサブクラスという。

```ruby
class サブクラス名 extends スーパークラス名{
}
```

※継承できるクラスは１つだけ

※コンストラクタは継承しない

コンストラクタのルールで、メソッド名をクラス名と合わせるというルールーがあったがそのルールに合わなくなる。

ただしサブクラスからすーぱクラスのコンストラクタを呼び出して利用することは可能

## オーバーライド

オーバーライド：サブクラスでスーパークラスのメソッドを再定義すること

条件：以下を一致させる

- 戻り値の型
- メソッド名
- 引数の型と数

### this superの使い方

this：自オブジェクトの～（Rubyのselfみたいなもの）

super：スーパークラスの～

①今まで、引数をメンバ変数を区別する為に、別の名前を指定してきたが以下のように書くことができる。

```ruby

public class Student {
	String name;
	
	Student(String n) {
		name = n;
	}
}
	
	↓↓↓こうなる
	
public class Student {
	String name;
	
	Student(String name) {
		this.name = name;
	}
}	
```

②スーパークラスのメソッドを呼び出したいときは

`super.メソッド名` で呼び出すことができる。

```ruby
class Animal {
    void speak() {
        System.out.println("何かの動物が鳴いています");
    }
}

class Dog extends Animal {
    void speak() {
        super.speak();
        System.out.println("ワンワン！");
    }
}

```

③コンストラクタの呼び出し

`this(引数)、super(引数)`

※必ずコンストラクタ内の先頭に記述

例：thisを使った同じクラス内のコンストラクタの呼び出し

```ruby
class Student {
    String name;
    int score;

    // ① メインのコンストラクタ
    Student(String name, int score) {
        this.name = name;
        this.score = score;
    }

    // ② 別のコンストラクタ（score を 0 にしたい場合）
    Student(String name) {
        this(name, 0);  // ← this(...) で①のコンストラクタを呼ぶ
    }
}

```

例：superを使ったスーパークラスのコンストラクタの呼び出し
```
class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }
}

class Dog extends Animal {
    int age;

    Dog(String name, int age) {
        super(name);  // ← 親クラス Animal のコンストラクタを呼ぶ
        this.age = age;
    }
}
```