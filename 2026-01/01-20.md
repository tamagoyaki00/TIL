学習記録！～Java～
やっぱり身近なものに例えると内容が理解しやすいなぁと実感した一日でした。
今まで例外処理をあまりやってこなかったので、言っていることは理解できても実際使ってみるのが難しい。明日演習問題を実行する。

## ポリモフィズム

### 抽象クラス

★共通の性質は決めるけど、具体的な動きは子クラスに任せるイメージ

ルール

- インスタンス化できない
- 共通のフィールドやメソッドは持てる
- 抽象メソッド（中身がないメソッド）を定義できる
- 子クラスでその抽象メソッドを実装する
- abstractをクラス名・メソッドにつける

例：動物の泣き方を表す抽象クラス

```ruby
public abstract class Animal {
    // 共通のフィールド
    String name;

    // コンストラクタ
    public Animal(String name) {
        this.name = name;
    }

    // 共通のメソッド
    public void introduce() {
        System.out.println("私は " + name + " です。");
    }

    // 抽象メソッド（中身なし）
    public abstract void makeSound();
}

```

子クラスで具体的な動きを記述

```ruby
public class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

// オーバーライドして抽象メソッドの中身を記述
    public void makeSound() {
        System.out.println("ワンワン！");
    }
}

```

別の子クラス

```ruby
public class Cat extends Animal {
    public Cat(String name) {
        super(name);
    }

 // オーバーライドして抽象メソッドの中身を記述
    public void makeSound() {
        System.out.println("ニャー！");
    }
}

```

実行

```ruby
Animal dog = new Dog("ポチ");
dog.introduce();   // 共通メソッド
dog.makeSound();   // 子クラスごとの実装

Animal cat = new Cat("タマ");
cat.introduce();
cat.makeSound();

// 出力
私はポチです。
ワンワン！
私はタマです。
ニャー！
```

このように型は同じAnimalだが実際の処理がオブジェクトによって異なることをポリモフィズム（多態性）という

**メリット**

- 実装すべきメソッドや処理などが明確になり、設計ミスが防げる
- 拡張していきやすい
- コードの重複が減る

## インタフェース

インタフェース：定数と抽象メソッドのみを定義できる

`interface インターフェース名{}`

```ruby
public interface Englishable{
	String LANG = "英語"; // public static finalをかかなくても裏で処理
	void displayEng(); // public abstract をかかなくても裏で処理
}
```

クラスを引き継ぐのは継承（extends）

インタフェースを引き継ぐのは**実装(implements)**という。

実装したクラスではすべてのメソッドの処理を定義する必要がある。（抽象メソッドなので）

インタフェースは複数実行できる

インタフェースは共通してできることを記述

継承は、スーパークラスを基に追加する。

APEXで例えると、全レジェンドができることをインタフェースで定義（ここではパッシブ・アビリティ・ウルト）

```ruby
public interface PassiveAbility {
    void passive();
}

public interface TacticalAbility {
    void tactical();
}

public interface UltimateAbility {
    void ultimate();
}

```

全レジェンドの共通性質を抽象クラスにまとめる

```ruby
public abstract class Legend implements PassiveAbility, TacticalAbility, UltimateAbility {
    protected String name;
    protected int hp;

    public Legend(String name) {
        this.name = name;
        this.hp = 100;
    }

    public void introduce() {
        System.out.println("私は " + name + " です。");
    }
}

```

レイス特有の能力を継承で記述

```ruby
public class Wraith extends Legend {

    public Wraith() {
        super("レイス");
    }

    @Override
    public void passive() {
        System.out.println("パッシブ：危険察知（声が聞こえる）");
    }

    @Override
    public void tactical() {
        System.out.println("戦術：虚空へ");
    }

    @Override
    public void ultimate() {
        System.out.println("ウルト：ディメンションリフト（ポータル）");
    }
}

```

## パッケージ

パッケージ：複数のクラスをまとめる仕組み

### パッケージの宣言

```ruby
package パッケージ名;
```

パッケージは階層を作成できるためその場合は上の改装からドット（.）で繋げて記述

```ruby
package practiceA.practiceB.practiceC;
```

package import classの記述する順番

**package　→　import　→　class**

クラスをパッケージ化するとクラス名が変わる

```ruby
package名.クラス名(完全修飾名という)
```

### パッケージクラスの利用

package名.クラス名と書くこともできるが、面倒な為、

importしてパッケージ名を省略することができる

```ruby
import 完全修飾名;

// パッケージの中で読み込みたいクラスがたくさんある場合
import pack.*;
```

パッケージは名前空間。Rubyでいうmoduleのイメージ。

Javaにはただファイルを分けたい⇒ディレクトリを分けるのようなことがなく

ディレクトリを作る　＝　パッケージを作るの感覚

より構造の設計が必要にあんる。

## 例外

例外が発生すると例外クラスのオブジェクトが自動生成される（Rubyと一緒）

### 例外処理

```ruby
try {
    // 例外が発生する可能性のあるコード
} catch (ExceptionType1 e1) {
    // ExceptionType1の例外を処理するコード
} catch (ExceptionType2 e2) {
    // ExceptionType2の例外を処理するコード
} finally {
    // 例外の発生有無にかかわらず実行されるコード
}
```

※catchを複数書く時はサブクラスからかく

### throwとthrows

throw 例外オブジェクト:例外を強制的に発生させる

throws 例外クラス: メソッドがその例外を発生させることを宣言する