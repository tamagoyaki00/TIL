## React

### 再レンダリング
参考:  
https://qiita.com/yokoto/items/ee3ed0b3ca905b9016d3#1-react-%E3%81%AE%E5%86%8D%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%A8%E3%81%AF%E4%BD%95%E3%81%8B

すでに画面に表示されているコンポーネントで発生する2回目以降のレンダリングのこと

再レンダリングの流れ

- コンポーネントの再評価: 
コンポーネントが再実行され、新しい仮想DOMが生成されます。

- 仮想DOMの差分計算: 
Reactは前回の仮想DOMと新しく生成した仮想DOMを比較し、どの部分が変更されたかを検出します。

- 実際のDOMへの反映: 
差分のある部分のみ実際のDOMに対して更新を行います。

- ブラウザによる再描画: 
最終的に、実際のDOMが更新されると、ブラウザがその変更を反映して画面を再描画します。

この仕組みにより、Reactは最小限のDOM更新で効率的にUIを更新することができます。

コンポーネントが再レンダリングされる原因
- 状態（state）の変更
- 親 (または子/children) の再レンダリング
- Context の変更
- React hooks の変更
※詳しいことは参考URLに記述されている

再レンダリングが多発したり、重いファイルだったりするとパフォーマンスに影響がでる。（RubyでいうN＋1問題みたいなもの）

## 再レンダリング防止
[コンポジションを使って再レンダリングを防ぐ](https://qiita.com/yokoto/items/ee3ed0b3ca905b9016d3#3-%E3%82%B3%E3%83%B3%E3%83%9D%E3%82%B8%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E5%86%8D%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%82%92%E9%98%B2%E3%81%90)

### React.memo
受け取るpropsが前回と同じ場合に、コンポーネントの再レンダリングをスキップする

### useCallback
コンポーネント内で定義するイベントハンドラやコールバック関数をメモ化することで、毎回新しい関数が生成されるのを防ぎ、子コンポーネントへの不要なprops変更を避ける

### useMemo
重い計算処理やオブジェクト生成の結果をメモ化し、同じ計算を毎回実行するのを防ぐ

## paiza
Cランク  
`tally` self に含まれる要素を数え上げた結果を Hash で返します。
```
 ["a", "b", "c", "b"].tally  #=> {"a"=>1, "b"=>2, "c"=>1}
```
