引越しも落ち着いたので、今日から勉強再開！

Javaの学習とpaiza(ruby)をやりました。
すこし期間があいてしまいましたが、
前回ログイン機能を実装して、理解できていないところで終わっていたので、そこから！

**JavaにおいてDBに保存してある情報を扱うために必要なものは**

@Entity （データの入れ物）

@Repository　SQLを発行してDBとやり取りする窓口

@Service　ビジネスロジックを書く場所

※Rails の Model が全部やってくれていたことを、Java は3つに分けているイメージ。

[Controller]
↓
[Service]  ← ロジック（ログイン判定など）
↓
[Repository]  ← SQL を自動生成して DB と通信
↓
[Entity]  ← DB の1行を表すオブジェクト
↓
[DB]

まず、Entityを用意。

```ruby
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

import lombok.Data;

@Entity
@Table(name  = "user_info") //どのテーブルかを明示
@Data

public class UserInfo {
	@Id　// primaryキーの場合は必要
	private String loginId;
	private String password;

}
```

※仮にuser_infoにemailやavatarなどのカラムがあっても、ログインに必要なものがloginIdとpasswordだけなのであれば上記のように必要なものだけを記述すればいい

**次に、Repositoryを用意**

```ruby
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.example.demo.entity.UserInfo;

@Repository
public interface UserInfoRepository extends JpaRepository<UserInfo, String> {
	UserInfo findByLoginId(String loginId);
}
```

`@Repository`をつけて、かつJpaRepositoryを継承する必要がある。

この`JpaRepository`を継承することで、SQL を書かなくても CRUD 操作（findAll, findById, save, delete など）が自動で使えるようになる

`JpaRepository`のジェネリクス(<>)には、対象となるエンティティクラスと、その主キーの型を指定する。

**Serviceクラスを用意**

```ruby
import java.util.Optional;

import org.springframework.stereotype.Service;

import com.example.demo.entity.UserInfo;
import com.example.demo.repository.UserInfoRepository;

import lombok.RequiredArgsConstructor;

@Service
@RequiredArgsConstructor
public class LoginService {
	private final UserInfoRepository repository;

	public Optional<UserInfo> searchUserById(String loginId){
		return repository.findById(loginId);
	}
}
```

`@RequiredArgsConstructor`

を使うことで自動的にコンストラクタを生成してくれる。

自分で書くのであれば以下と同じ意味。

```ruby
public LoginService(UserInfoRepository repository) {
    this.repository = repository;
}

```

`Optional<型>`

Optionalは値をラップし、その値がnullかもしれないことを表現するクラスです。

ここでは入力されたユーザーIDが登録されていないことも予想される為、このようにかいています。

### パスワードをハッシュ化
promファイルに以下を追加
公式通り（https://docs.spring.io/spring-security/reference/getting-spring-security.html）
```
<dependency>
<groupId>org.springframework.boot</groupId>
<artifactId>spring-boot-starter-security</artifactId>
</dependency>
 ```

Beanファイルを作成
```
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;


@Configuration
public class BeanDefine {
	
	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
}
```

@Configurationは「このクラスには Bean 定義が書かれていますよ」という宣言
@Beanは「このメソッドの戻り値を Spring の DI コンテナに登録してね」という意味
→ 登録されたインスタンスは アプリ全体で使える

この@Beanを理解する前にSpringのDIについて理解したほうがわかりやすかった。
分かりやすい記事→https://qiita.com/rebi/items/31169e5bcd64b4411f19

簡単にいうと、@Beanを使うことで、依存性が低くなり、保守性、再利用性、テスト性が向上するこのコードは「Spring Security のパスワードハッシュ化機能（BCrypt）を Bean として登録して、アプリ全体で使えるようにしている

この@Beanで保存したものを利用する側は
```
private final PasswordEncoder passwordEncoder;
```

このようにfinal を付けると、Java の仕様上
- コンストラクタで必ず値がセットされる
- 後から変更できない
となるのでfinalを付けることは必須ではないが、基本的には`final 型　変数名`で呼び出す